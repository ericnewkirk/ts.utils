% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quiet_period.R
\name{dynamic_quiet_period}
\alias{dynamic_quiet_period}
\title{dynamic_quiet_period}
\usage{
dynamic_quiet_period(event_dates, quiet_period, rolling = TRUE, batch = TRUE)
}
\arguments{
\item{event_dates}{a vector \code{POSIX} timestamps when the event of
interest occurred}

\item{quiet_period}{the interval used for clustering, preferably defined
with a function from the \code{lubridate} package (e.g.
\code{lubridate::hours} or \code{lubridate::minutes})}

\item{rolling}{a logical scalar determining how the quiet period is applied,
see details section}

\item{batch}{a logical scalar controlling the return type, see return section}
}
\value{
if \code{batch = TRUE} \code{dynamic_quiet_period} returns an integer
vector suitable for additional grouping/summary, otherwise
\code{dynamic_quiet_period} returns a logical vector indicating which
elements of \code{event_dates} satisfy the criteria defined by the
\code{quiet_period} argument
}
\description{
Clusters irregular time series data using a quiet period defined by the
time elapsed since the last event (\code{rolling = TRUE}) or the
start of the previous cluster (\code{rolling = False}).
}
\examples{

if (requireNamespace("lubridate", quietly = TRUE)) {
  # cleaner with `lubridate`
  start <- lubridate::ymd_hms("2025-01-01 12:00:00")
  elapsed_min <- lubridate::minutes(
    c(5, 11, 31, 32, 35, 60, 62, 63, 150, 155)
  )
  events <- data.frame(
    event_date = start + elapsed_min
  )
  qp <- lubridate::minutes(30)
} else {
  # but it can be done with base R
  start <- as.POSIXct("2025-01-01 12:00:00")
  elapsed_min <- c(5, 11, 31, 32, 35, 60, 62, 63, 150, 155)
  events <- data.frame(
    event_date = start + elapsed_min * 60
  )
  qp <- 30 * 60 # 30 minutes in seconds
}

if (requireNamespace("dplyr", quietly = TRUE)) {
  # same goes for `dplyr`
  events  |>
    dplyr::mutate(
      include_roll = dynamic_quiet_period(event_date, qp, batch = FALSE),
      batch_roll = dynamic_quiet_period(event_date, qp),
      include_noroll = dynamic_quiet_period(
        event_date,
        qp,
        rolling = FALSE,
        batch = FALSE
      ),
      batch_noroll = dynamic_quiet_period(event_date, qp, rolling = FALSE)
    )
} else {
  events$include_roll <- dynamic_quiet_period(event_date, qp, batch = FALSE)
  events$batch_roll <- dynamic_quiet_period(event_date, qp)
  events$include_noroll <- dynamic_quiet_period(
    event_date,
    qp,
    rolling = FALSE,
    batch = FALSE
  )
  events$batch_roll <- dynamic_quiet_period(event_date, qp, rolling = FALSE)
  events
}

}
